什么是粘包、拆包

粘包、拆包是Socket编程中最常遇见的一个问题，本文来研究一下Netty是如何解决粘包、拆包的，首先我们从什么是粘包、拆包开始说起：

TCP是个"流"协议，所谓流，就是没有界限的一串数据，TCP底层并不了解上层业务的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上：
一个完整的包可能会被TCP拆分为多个包进行发送（拆包）
多个小的包也有可能被封装成一个大的包进行发送（粘包）
这就是所谓的TCP粘包与拆包

下图演示了粘包、拆包的场景：


 基本上有四种情况：

Data1、Data2都分开发送到了Server端，没有产生粘包与拆包的情况
Data1、Data2数据粘在了一起，打成了一个大的包发送到了Server端，这种情况就是粘包
Data1被分成Data1_1与Data1_2，Data1_1先到服务端，Data1_2与Data2再到服务端，这种情况就是拆包
Data2被分成Data2_1与Data2_2，Data1与Data2_1先到服务端，Data2_2再到服务端，同上，这也是一种拆包的场景


粘包、拆包产生的原因

上面我们详细了解了TCP粘包与拆包，那么粘包与拆包为什么会发生呢，大致上有三种原因：

应用程序写入的字节大小大于Socket发送缓冲区大小
进行MSS大小的TCP，MSS是最大报文段长度的缩写，是TCP报文段中的数据字段最大长度，MSS=TCP报文段长度-TCP首部长度
以太网的Payload大于MTU，进行IP分片，MTU是最大传输单元的缩写，以太网的MTU为1500字节


粘包、拆包解决策略

由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，可以归纳如下：
消息长度固定，累计读取到长度总和为定长LEN的报文后，就认为读取到了一个完整的消息，将计数器重置，重新读取下一个消息
将回车换行符作为消息结束符，例如FTP协议，这种方式在文本协议中应用比较广泛
将特殊的分隔符作为消息的结束标志，回车换行符就是一种特殊的结束分隔符
通过在消息头中定义长度字段来标志消息的总长度
Netty对上面4种方式做了统一的抽象，提供了4种解码器来解决对应的问题，使用起来非常方便，有了这些解码器，用户不需要自己对读取的报文进行人工解码，也不需要考虑TCP的粘包和拆包。